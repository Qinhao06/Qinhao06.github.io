<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统部分笔记</title>
      <link href="/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h4 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h4><p>每个线程都是CPU使用的一个基本单元。</p><p>包括线程ID，程序计数器，寄存器组和堆栈</p><p>和其他线程共享代码数据和其他资源。</p><h6 id="线程优点"><a href="#线程优点" class="headerlink" title="线程优点"></a>线程优点</h6><ul><li><p>响应性 </p></li><li><p>资源共享</p></li><li><p>经济</p></li><li><p>可伸缩性</p></li></ul><h4 id="多核编程"><a href="#多核编程" class="headerlink" title="多核编程"></a>多核编程</h4><p>多个计算核的计算系统称之为多核或者多处理器系统。多核系统具有并行执行</p><h6 id="编程挑战："><a href="#编程挑战：" class="headerlink" title="编程挑战："></a>编程挑战：</h6><p>多核编程任务具有五个方面的挑战：</p><ul><li><p>识别任务：查找分析应用程序找到独立的并发的任务</p></li><li><p>平衡：任务选择</p></li><li><p>数据分割：不同的核应有不同的数据执行不同的任务</p></li><li><p>数据依赖：分析多个任务之间的依赖关系。一个任务可能依赖于另一个任务，此时需要保证任务执行的同步</p></li><li><p>测试与调试：程序运行多核有很多不同的执行路径，测试的难度上升</p></li></ul><h6 id="并行类型"><a href="#并行类型" class="headerlink" title="并行类型"></a>并行类型</h6><ul><li><p>数据并行：将问题数据分到不同核上，不同核执行相同任务。</p></li><li><p>任务并行：将任务（线程）分配到多个计算核。每个线程都会自行一个独特的操作。</p></li></ul><h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>两种不同的方法可以提供线程支持：用户层的用户线程或者内核层的内核线程。用户线程位于内核之上，不需内核管理，但是内核线程需要由操作系统直接支持和管理</p><h6 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h6><p>线程的管理是由用户空间的线程库来完成。不过，如果一个线程管理执行阻塞系统调用，那么整个进程都会阻塞。同时因为一次只有一个线程可以访问内核，由此导致多核处理系统没有效率。</p><h6 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h6><p>一对一避免了多对一的所有缺点，但是创建过多的内核线程会影响程序的性能，但是大都数的系统都限制了数量。</p><h6 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h6><p>   </p><p>开发人员可以创建任意多的用户线程，并且相应的内核线程能在多处理器系统上并发执行。</p><p>双层模型：在多对多的基础上允许一对一</p><h4 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h4><p>两种实现方式</p><ul><li><p>在用户空间中提供一个没有内核支持的库，库的所有代码和数据结构位于用户空间，调用只是用户空间本地的函数调用</p></li><li><p>操作系统直接支持的内核级库，库中API通常导致对内核系统调用</p></li></ul><h6 id="隐式多线程"><a href="#隐式多线程" class="headerlink" title="隐式多线程"></a>隐式多线程</h6><p>将多线程的创建和管理交给编译器和运行时库来完成，这种策略称之为隐式线程</p><h6 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h6><p>在进程开始时创建一定数量的线程，并加入池中等待工作</p><p>优点：</p><ul><li><p>用现有线程服务请求比等待创建一个线程更快</p></li><li><p>线程池限制了可用线程数量</p></li><li><p>将要执行任务从创建任务的机制中分离，允许我们采用不同策略运行任务。</p></li></ul><h6 id="OpenMp"><a href="#OpenMp" class="headerlink" title="OpenMp"></a>OpenMp</h6><p>为一组编译指令和API，支持共享内存环境下的并行编程。其识别并行区域，可并行运行代码块。</p><h6 id="大中央调度（GCD）"><a href="#大中央调度（GCD）" class="headerlink" title="大中央调度（GCD）"></a>大中央调度（GCD）</h6><p>Apple Mac OS X和ios的一种技术，提供块的扩展。每块只是工作的一个独立单元。通过将块放在调度队列上让线程池调用</p><h4 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h4><h6 id="系统调用fork和exec（）"><a href="#系统调用fork和exec（）" class="headerlink" title="系统调用fork和exec（）"></a>系统调用fork和exec（）</h6><h6 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h6><ul><li><p>信号是由特定的事件发生而产生的</p></li><li><p>信号被传递给某个进程</p></li><li><p>信号一旦收到就该处理</p></li></ul><p>同步信号的例子包括非法访问内存和被0所除。</p><p>而异步信号是由运行程序以外的事件产生的，进程就异步接收，比如特殊键终止或者定时器到期。</p><p>信号处理程序可以分为：</p><ul><li><p>缺省信号处理程序</p><p>每个信号都有缺省信号处理程序，由内核来运行</p></li><li><p>用户定义的信号处理程序</p><p>由用户决定如何处理</p></li></ul><p>对于多线程进程，信号选择：</p><ul><li><p>传递到信号适用线程</p></li><li><p>传递到每个线程</p></li><li><p>传递到某些线程</p></li><li><p>规定特定线程接受进程所有信号</p></li></ul><p>信号传递取决于信号产生方式</p><h6 id="线程撤销"><a href="#线程撤销" class="headerlink" title="线程撤销"></a>线程撤销</h6><p>线程撤销就是在线程完成之前终止线程。</p><p>需要撤销的线程，通常为目标线程。目标线程撤销分别为：</p><ul><li><p>异步撤销：一个线程立即终止目标线程</p></li><li><p>延迟撤销：目标线程不断检查自身是否应该终止，这允许目标线程能够有序终止自己。</p></li></ul><h6 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h6><p>在某些情况下，每个线程可能需要自己的某些数据。称这种数据为线程本地存储（TLS）。其类似于静态数据，不同是其是每个线程所独有的。</p><h6 id="调度程序激活"><a href="#调度程序激活" class="headerlink" title="调度程序激活"></a>调度程序激活</h6><p>许多系统在实现多对多或者双层模型时，在用户和内核线程之间增加一个中间数据结构。这个数据结构称为轻量级进程（LWP）。</p><p>用户线程库和内核之间的一种通信方案称为调度器激活。工作方式如下：</p><p>内核提供一组LWP给应用程序，而应用程序可以调度用户线程到任何一个LWP。此外内核应将特定的事件通知应用程序。该步骤称为回调，由线程库通过回调处理程序来处理。</p><h4 id="操作系统例子"><a href="#操作系统例子" class="headerlink" title="操作系统例子"></a>操作系统例子</h4><h6 id="Windows线程"><a href="#Windows线程" class="headerlink" title="Windows线程"></a>Windows线程</h6><p>线程包括：</p><p>线程主要数据结构：</p><h6 id="Linux线程"><a href="#Linux线程" class="headerlink" title="Linux线程"></a>Linux线程</h6><h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>对于支持线程的操作系统，操作系统实际调度的是内核级线程而非进程</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h6 id="CPU-I-O-执行周期"><a href="#CPU-I-O-执行周期" class="headerlink" title="CPU-I/O 执行周期"></a>CPU-I/O 执行周期</h6><p>进程执行包括周期进行CPU执行和I/O等待</p><p>而CPU执行时间如图：</p><p>大多数为短CPU执行和少量长CPU执行</p><h6 id="CPU调度程序"><a href="#CPU调度程序" class="headerlink" title="CPU调度程序"></a>CPU调度程序</h6><p>每当CPU空闲时，进程选择采用短期调度程序或cPU程序选择内存中可执行的进程。特别的是就绪队列不必是FIFO队列，而队列中的记录通常为PCB。</p><h6 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h6><p>需要进行CPU调度有四种情况：</p><p>对于1，4智能进行调度，而2，3是可以选择的</p><p>如果调度智能发生在1，4两种情况，则调度方案称为<strong>非抢占的</strong> 或者协作的。否则低啊都方案称为抢占的。在非抢占调度下，就只有1，4两种情况。</p><p>抢占调度涉及需要更改内核部分的一些策略，比如定时器和一些调度，中断策略。</p><h6 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h6><p>调度程序是一个模块，用来将CPU控制交给由短期调度程序选择的进程。其功能包括：</p><ul><li><p>切换上下文</p></li><li><p>切换到用户模式</p></li><li><p>跳转到用户程序合适的位置，以便重新启动程序</p></li></ul><p>调度程序应该尽可能的块，每次进程切换时都要使用。调度程序停止一个进程而启动另一个进程所需的时间称为调度延迟。</p><h4 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h4><ul><li><p>CPU使用率</p></li><li><p>吞吐量：一个时间单元内进程完成的数量</p></li><li><p>周转时间：从进程提交到进程完成的时间段称为周转时间。</p></li><li><p>等待时间：在就绪队列中等待所花时间之和</p></li><li><p>响应时间：从请求到产生第一响应的时间，是开始响应所需的时间，而非输出响应所需的时间。</p></li></ul><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h6 id="先到先服务调度（FCFS）"><a href="#先到先服务调度（FCFS）" class="headerlink" title="先到先服务调度（FCFS）"></a>先到先服务调度（FCFS）</h6><p>使用FIFO队列实现，但是缺点是平均等待时间往往很长。</p><h6 id="最短作业优先调度（SJF）"><a href="#最短作业优先调度（SJF）" class="headerlink" title="最短作业优先调度（SJF）"></a>最短作业优先调度（SJF）</h6><p>最短下次CPU执行算法，调度取决于进程下次CPU执行的长度。通过贪心证明，该调度方法为最优的，但是其实现需要知道下次CPU执行长度，其中一个方法是可以将用户提交作业时指定的进程时限作为长度。SJF常用于长期调度。</p><p>但是对于短期调度，我们可以采用预测的方式去判断选取的进程。</p><p>SJF算法可以是抢占的或者非抢占的，抢占的SJF调度有时候称为最短剩余时间优先调度</p><h6 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h6><p>每个进程都有一个优先级，具有相同优先级的算法按FCFS（先来先服务），</p><p>优先级调度的问题在于无穷阻塞或饥饿，解决的方式是老化</p><h6 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h6><p>专门为分时系统设计，其将一个较小的时间单元定义为时间量或者时间片，就绪队列为循环队列</p><h6 id="多级队列调度"><a href="#多级队列调度" class="headerlink" title="多级队列调度"></a>多级队列调度</h6><p>进程通常分为前台和后台进程。不同进程要求不同调度要求，由此出现多级队列，</p><h6 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h6><p>多个队列，当一个第一次进入CPU中执行未成功时，进入下一个队列</p><h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>用户级（线程库）和内核级线程（操作系统）</p><h4 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h4><h6 id="多处理器调度方法"><a href="#多处理器调度方法" class="headerlink" title="多处理器调度方法"></a>多处理器调度方法</h6><p>第一种采用非对称多处理，只有一个处理器（主服务器）处理所有调度决定，I/O处理以及其他系统活动，其他处理器只处理用户代码</p><p>第二种使用对称多处理（SMP）</p><h6 id="处理器亲和性"><a href="#处理器亲和性" class="headerlink" title="处理器亲和性"></a>处理器亲和性</h6><p>尽量将一个进程运行在一个处理器上，通过操作系统称为软亲和性，通过系统调用来支持硬亲和性。</p><p>同时系统内存架构可以影响处理器的清河性</p><h6 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h6><h6 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h6><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><h5 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h5><h6 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h6><ul><li><p>进程是执行的程序</p></li><li><p>进程包括程序代码（文本段），当前活动（程序计数器，处理器寄存器当前处理内容等） ，进程堆栈（包括临时数据），数据段（全局遍历），堆（看是否有分配）。</p></li></ul><h6 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h6><ul><li><p>新的：创建</p></li><li><p>运行：</p></li><li><p>等待：等待某个事件</p></li><li><p>就绪：等待分配处理器</p></li><li><p>终止：执行完成</p></li></ul><p>一次只有一个进程运行，其余进程可以处在就绪或者等待状态。</p><hr><h6 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h6><p>操作系统内的每个进程表示，采用进程控制块（Process Control Block， PCB）（任务控制块， task control block），PCB：</p><ul><li><p>进程状态</p></li><li><p>程序计数器：下个指令地址</p></li><li><p>CPU寄存器：不同体系不同寄存器类型和数量，包括累加器，索引寄存器，堆栈只做，通用寄存器和其他条件码信息寄存器。</p></li><li><p>CPU调度信息：包括进程优先级，调度队列的指针和其他参数</p></li><li><p>内存管理信息：包括基地址和界限寄存器的值，页表和段表</p></li><li><p>记账信息：CPU时间，实际使用时间，时间期限，记账数据，作业或进程数量等。</p></li><li><p>I/O状态信息：分配给进程的I/O设备列表和打开文件列表等。</p></li></ul><hr><h6 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h6><p><strong>线程</strong>（英语：thread）是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">操作系统</a>能够进行运算<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6?fromModule=lemma_inlink">调度</a>的最小单位。它被包含在<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>之中，是<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>中的实际运作单位。一条线程指的是<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B?fromModule=lemma_inlink">进程</a>中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及<a href="https://baike.baidu.com/item/SunOS?fromModule=lemma_inlink">SunOS</a>中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><hr><h4 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h4><p>进程调度器选择一个可用进程到CPU上执行。</p><h6 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h6><ul><li><p> 进程在进入系统时会加入作业队列（包括系统内所有进程）</p></li><li><p> 驻留在内存中，就绪的，等待运行的进程保存在就绪队列（尝试链表实现）</p></li><li><p>设备队列，多进程请求设备时需要进行排队等待。</p></li><li><p>调度常使用队列图,当进程被CPU执行后，有：</p><ul><li><p>发出I/O请求，进入I/O队列</p></li><li><p>创建新的子进程，等待终止</p></li><li><p>被中断而强制释放CPU，并放回到就绪队列</p></li></ul></li></ul><hr><h6 id="调度程序-1"><a href="#调度程序-1" class="headerlink" title="调度程序"></a>调度程序</h6><p>进程选择通过适当调度器或调度程序来执行</p><ul><li><p>长期调度程序或作业调度程序</p><ul><li><p>从缓冲池中选择进程加到内存</p></li><li><p>执行频率较低</p></li></ul></li><li><p>短期调度程序或CPU调度程序</p><ul><li><p>从准备执行的进程中选择进程</p></li><li><p>短期调度程序执行频率高，每100ms至少一次</p></li></ul></li><li><p>长期调度程序控制多道程序程度（内存中的进程数量），由于创建进程的平均速度要等于离开进程的平均速度，所以只有在进程离开系统时需要长期调度程序调度。</p><p>其中大多数进程分为I/O密集型进程和CPU密集型进程，</p></li><li><p>中期调度程序（某些系统），核心思想为将进程从内存（或CPU竞争）中移出，降低多道程序程度，之后在重新调回内存，并从中断继续执行（交换）</p></li></ul><hr><h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><ul><li><p>系统通过保存上下文实现挂起进程和恢复进程</p></li><li><p>采用进程PCB表示，包括CPU寄存器的值，进程状态和内存管理信息</p></li><li><p>切换方式： 首先执行状态保存，保存当前CPU状态（包括内核模式和用户模式），之后 状态恢复重新开始下运行</p></li><li><p>切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程的状态，这个惹怒称为上下文切换。</p></li><li><p>上下文切换为纯粹时间开销</p></li></ul><hr><h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><h6 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h6><p>进程创建可以形成进程树。</p><ul><li><p>进程识别采用唯一的进程标识符（通常是一个整数值，称之为PID）</p></li><li><p>一般来说，子进程可以从操作系统直接获得资源或者从父进程那里获得资源子集（可以限制创建过多进程导致系统超载）</p></li><li><p>父进程也可以向子进程传递初始化数据，同时有两种执行可能：</p></li><li><p>Linux可以使用fork来创建一个子进程，子进程回复制原来进程的地址空间（使得子进程与父进程可以轻松通信），但是调用fork 的返回值，父进程拿到的是子进程的PID，</p></li><li><p>Windows采用CreateProcess（）创建进程（要求将特定程序加载进子进程的地址空间），</p></li></ul><hr><h6 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h6><ul><li><p>当进程完成执行最后语句并通过系统调用exit（）让操作系统删除自身是，进程终止。</p></li><li><p>终止时进程可以返回状态值到父进程，其余资源会通过操作系统释放</p></li><li><p>通常也可由其他进程通过系统调用实现对另一进程的终止。通常只有父进程才可以实现，但是父进程需要子进程的PID有些系统不允许子进程在父进程终止的情况下存在，那么终止父进程也会相应的终止子进程，这种现象称为级联终止。</p></li><li><p>僵尸进程：当进程终止时，系统会释放其资源，但是在进程表中的条目仍存在直到父进程调用wait（）。</p></li><li><p>孤儿进程：父进程在其终止后未调用wait，Linux处理方式是将init进程作为孤儿进程的父进程，通过init进程定期调用wait实现回收。</p></li></ul><hr><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程可以是独立的也可以是协作的。</p><p>进程协作理由：</p><ul><li><p>信息共享：提供环境以允许并发访问信息</p></li><li><p>计算加速：将特定的任务拆分为子任务并行执行。</p></li><li><p>模块化：按照模块化的方式构造系统则需要将系统功能分成独立的线程或进程。</p></li><li><p>方便：并行任务</p></li></ul><p>进程间通信：</p><ul><li><p>共享内存</p></li><li><p>消息传递</p></li><li><p>对于多个处理核系统，消息传递的性能要优于共享内存。共享内存存在高速缓存一致性问题。</p></li></ul><h6 id="共享内存系统"><a href="#共享内存系统" class="headerlink" title="共享内存系统"></a>共享内存系统</h6><ul><li>    生产者消费者通过产生缓冲区（共享内存），缓冲区分为无界缓冲区和有界缓冲区</li></ul><h6 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h6><ul><li>  进程通信需要实现通信链路，用send（）和receive（）：<ul><li><p>直接或者间接的通信</p><ul><li><p>直接通过指定进程</p></li><li><p>间接通过发送到共有邮箱实现</p><ul><li><p>邮箱为进程所有时，需要区分所有者和使用者。</p></li><li><p>邮箱为操作系统所有时，提供邮箱服务，可以开发权限，默认创建邮箱的进程缺省为邮箱所有者</p></li></ul></li></ul></li><li><p>同步或者 异步的通信</p><p>- </p></li><li><p>自动或者显示的缓存</p><ul><li>传输的消息驻留在临时队列中</li></ul></li></ul></li></ul><h2 id="IPC例子"><a href="#IPC例子" class="headerlink" title="IPC例子"></a>IPC例子</h2><h2 id="客户机-服务器通信"><a href="#客户机-服务器通信" class="headerlink" title="客户机/服务器通信"></a>客户机/服务器通信</h2><h6 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h6><h6 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h6><p>  </p><h6 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h6><ul><li><p>普通管道</p><ul><li>单向</li></ul></li><li><p>命名管道</p></li></ul><h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p><strong>协作进程</strong>或能直接共享逻辑地址空间（代码和数据），或能通过文件或消息来共享数据。前一种一般通过线程实现，但是共享会导致数据的不一致性。</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>多个进程并发访问和操作同一数据并且执行结果和特定访问顺序有关，称为竞争条件。</p><p>在加上多核系统和不同部分都可以操作资源，那么本章的大部分为协作进程如何进行进程同步和进程协调</p><h4 id="临界区问题"><a href="#临界区问题" class="headerlink" title="临界区问题"></a>临界区问题</h4><p>假设系统有n个进程。每个进程有一段代码称为临界区，进程在执行该区时可能修改公共变量，更新一个表，写一个文件。那么对于系统应有的一个重要特征是没有两个进程可以在他们的临界区内同时执行。则临界区问题需要设计一个协议以便协作进程。进入临界区之前，进程先请求许可（代买实现为进入区）。临界区之后有退出区，其他代码称为剩余区。</p><p>对于临界区应：</p><ul><li><p>互斥：进程不同时在临界区</p></li><li><p>进步：如果没有进程在临界区内执行，并且有进程需要进入临界区，那么止于瓯那些不在剩余区内执行的进程可以参加选择，以便确定谁能下次直接进入临界区，而且这种选择不能无限推迟</p></li><li><p>有限等待：进程申请进入临界区知道申请允许为止，其他进程允许进入临界区的次数具有上限</p></li></ul><p>而对于操作系统的活动进程使用内核代码的竞争条件常有两种方法</p><p><strong>抢占式内核</strong> ：允许处于内核模式的进程被抢占</p><p><strong>非抢占式内核</strong> ：不允许处于内核模式的进程被抢占，直到进程推出内核模式或阻塞或放弃cpu控制</p><h4 id="Peterson解决方案"><a href="#Peterson解决方案" class="headerlink" title="Peterson解决方案"></a>Peterson解决方案</h4><p>目前对于现代计算机不能保证正确运行</p><p>Peterson 解决方案使用于两个进程交错执行临界区和剩余区。</p><h4 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h4><p>通过加锁的方式来保护临界区。</p><p>通过一些简单的硬件指令，就可以有效解决临界区问题，硬件功能能够简化版编程工作和提高系统效率。</p><p>对于单处理器环境，临界区问题可以通过：在修改共享变量时禁止中断出现。这样能确保当前指令流可以有序执行，且不会被抢占。该方式常常为非 抢占式内核所采用。</p><p>对于多处理器环境通过中断禁止会很耗时，并且会影响通过中断更新的系统时钟。那么可以通过提供特殊的硬件指令，用于检测和修改字的内容，或者用于<strong>原子的</strong>交换两个字（不可中断指令）。</p><p>此处通过指令test_and_set()和compare_and_swap()体现这些指令背后的主要概念</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/2023/03/08/hello/"/>
      <url>/2023/03/08/hello/</url>
      
        <content type="html"><![CDATA[<p>你好，这是我的第一篇blog</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/08/hello-world/"/>
      <url>/2023/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
